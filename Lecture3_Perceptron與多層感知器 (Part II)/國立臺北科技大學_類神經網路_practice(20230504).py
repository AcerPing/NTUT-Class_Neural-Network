# -*- coding: utf-8 -*-
"""國立臺北科技大學_類神經網路_Practice(20230504).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/118RddM_LO82QQH9yyZZ_vUo9-DiVPCo1
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""## 講義第47頁"""

# Patterns
inputs = list()
inputs.append(np.array([1, 0.1, 0.1]))
inputs.append(np.array([1, 0.1, 0.95]))
inputs.append(np.array([1, 0.95, 0.1]))
inputs.append(np.array([1, 0.95, 0.95]))
inputs

# 隱藏層權重
Weight_InputToHiddenLayer = [[5.32, 3.13],
                [-3.73, -6.67],
                [-3.72, -6.61]]

# 內積
S_HiddenLayer = list()
for _input in inputs: 
  S_HiddenLayer.append(np.matmul(_input, Weight_InputToHiddenLayer))
S_HiddenLayer

print(1*5.32+0.1*(-3.73)+0.1*(-3.72))

print(1*3.13+0.1*(-6.67)+0.1*(-6.61))

# 為了利用Pandas Apply函數，特別轉換成Pandas
df_S_HiddenLayer = pd.DataFrame(S_HiddenLayer, columns=['H1', 'H2'])
df_S_HiddenLayer

def sigmoid(v):
    return 1 / (1 + np.exp(-v))

df_S_HiddenLayer = df_S_HiddenLayer.apply(sigmoid)
df_S_HiddenLayer

v = 4.5750	
1 / (1 + np.exp(-v))

numpy_S_HiddenLayer = np.array(df_S_HiddenLayer)
numpy_S_HiddenLayer

# 選擇四種不同的顏色
colors =  ['red', 'green', 'purple', 'orange']

# 在每個點上標出數字
for i in range(len(numpy_S_HiddenLayer)):
    plt.plot(numpy_S_HiddenLayer[i][0], numpy_S_HiddenLayer[i][1], 'o', color=colors[i])
    plt.text(numpy_S_HiddenLayer[i][0]+0.05, numpy_S_HiddenLayer[i][1]+0.05, str(f'Point_{i}'), color=colors[i])

# 設定x軸和y軸的範圍
plt.xlim(-0.5, 2)
plt.ylim(-0.5, 2)

# 顯示圖形
plt.show()

# 因為Point1及Point2數值很接近，所以會被蓋住。

# 插入X0 = 1
df_S_HiddenLayer.insert(0, 'H0', [1, 1, 1, 1])
df_S_HiddenLayer

# 轉成numpy
numpy_S_HiddenLayer = np.array(df_S_HiddenLayer)
numpy_S_HiddenLayer

# 輸出層權重
Weight_HiddenLayerToOutput = [[-3.08],
                [7.30],
                [-7.30]]
Weight_HiddenLayerToOutput

# 內積
S_Predict = list()
for _input in numpy_S_HiddenLayer:
  S_Predict.append(sigmoid(np.matmul(_input, Weight_HiddenLayerToOutput)))
S_Predict

import matplotlib.pyplot as plt

# 繪製直線
x = [-1, 1]
y = [0, 0]
plt.plot(x, y)

# 繪製四個點
colors = ['red', 'green', 'purple', 'orange']
i = 0
for (point, color) in zip(S_Predict,colors) :
    plt.scatter(point, 0, color=color)
    i += 1

# 顯示圖形
plt.show()

# 選擇四種不同的顏色
colors =  ['red', 'green', 'purple', 'orange']
# 繪製直線
plt.axhline(y=0, color='blue')

# 在每個點上標出數字
for i in range(len(S_Predict)):
    plt.plot(S_Predict[i], 0, 'o', color=colors[i])
    plt.text(S_Predict[i]+0.01, 0.1, str(S_Predict[i]), color=colors[i])

# 設定x軸和y軸的範圍
plt.xlim(-0.5, 2)
plt.ylim(-0.5, 0.5)

# 顯示圖形
plt.show()

"""## 講義第48頁"""

# Patterns
inputs = list()
inputs.append(np.array([1, 0.1, 0.1]))
inputs.append(np.array([1, 0.1, 0.95]))
inputs.append(np.array([1, 0.95, 0.1]))
inputs.append(np.array([1, 0.95, 0.95]))
inputs

# 隱藏層權重
Weight_InputToHiddenLayer = [[2.73, 3.51],
                [-6.37, 7.89],
                [6.60, -7.92]]

# 內積
S_HiddenLayer = list()
for _input in inputs: 
  S_HiddenLayer.append(np.matmul(_input, Weight_InputToHiddenLayer))
S_HiddenLayer

print(1*2.73+0.1*(-6.37)+0.1*(6.60))

print(1*3.51+0.1*(7.89)+0.1*(-7.92))

# 為了利用Pandas Apply函數，特別轉換成Pandas
df_S_HiddenLayer = pd.DataFrame(S_HiddenLayer, columns=['H1', 'H2'])
df_S_HiddenLayer

def sigmoid(v):
    return 1 / (1 + np.exp(-v))

df_S_HiddenLayer = df_S_HiddenLayer.apply(sigmoid)
df_S_HiddenLayer

v = 2.7530	
1 / (1 + np.exp(-v))

numpy_S_HiddenLayer = np.array(df_S_HiddenLayer)
numpy_S_HiddenLayer

# 選擇四種不同的顏色
colors =  ['red', 'green', 'purple', 'orange']

# 在每個點上標出數字
for i in range(len(numpy_S_HiddenLayer)):
    plt.plot(numpy_S_HiddenLayer[i][0], numpy_S_HiddenLayer[i][1], 'o', color=colors[i])
    plt.text(numpy_S_HiddenLayer[i][0]+0.05, numpy_S_HiddenLayer[i][1]+0.05, str(f'Point_{i}'), color=colors[i])

# 設定x軸和y軸的範圍
plt.xlim(-0.5, 2)
plt.ylim(-0.5, 2)

# 顯示圖形
plt.show()

# 因為Point0及Point3數值很接近，所以會被蓋住。

# 插入X0 = 1
df_S_HiddenLayer.insert(0, 'H0', [1, 1, 1, 1])
df_S_HiddenLayer

# 轉成numpy
numpy_S_HiddenLayer = np.array(df_S_HiddenLayer)
numpy_S_HiddenLayer

# 輸出層權重
Weight_HiddenLayerToOutput = [[-8.03, 8.44],
                [5.71, -5.59],
                [5.55, -5.44]]
Weight_HiddenLayerToOutput

# 內積
S_Predict = list()
for _input in numpy_S_HiddenLayer:
  S_Predict.append(sigmoid(np.matmul(_input, Weight_HiddenLayerToOutput)))
S_Predict

pd.DataFrame(S_Predict, columns=['H1', 'H2'])

print(sigmoid(1*(-8.03)+0.94008256*(5.71)+0.970886291*(5.55)))

print(sigmoid(1*(8.44)+0.94008256*(-5.59)+0.970886291*(-5.44)))

# 選擇四種不同的顏色
colors =  ['red', 'green', 'purple', 'orange']

# 在每個點上標出數字
for i in range(len(S_Predict)):
    plt.plot(S_Predict[i][0], S_Predict[i][1], 'o', color=colors[i])
    plt.text(S_Predict[i][0]+0.05, S_Predict[i][1]+0.05, str(f'Point_{i}, {S_Predict[i]}'), color=colors[i])

# 設定x軸和y軸的範圍
plt.xlim(-0.5, 2)
plt.ylim(-0.5, 2)

# 顯示圖形
plt.show()

# 因為Point1及Point2數值很接近，所以會被蓋住。